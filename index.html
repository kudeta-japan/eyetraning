.<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>視力トレーナー『Focus Play』</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --muted:#334155; /* slate-600 */
      --text:#e5e7eb; /* gray-200 */
      --accent:#22c55e; /* green-500 */
      --accent2:#3b82f6; /* blue-500 */
      --warn:#f59e0b; /* amber-500 */
      --err:#ef4444; /* red-500 */
      --ok:#10b981; /* emerald-500 */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif}
    .wrapper{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100%;padding:16px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,0.3)}
    .left{padding:16px;display:flex;flex-direction:column;gap:14px}
    .title{font-weight:800;font-size:22px;letter-spacing:0.2px}
    .subtitle{font-size:12px;color:#cbd5e1}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px}
    label{font-size:14px;color:#cbd5e1}
    select, input[type="range"], input[type="number"], button{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.1);background:#0b1220;color:var(--text)}
    button{cursor:pointer;font-weight:700;letter-spacing:0.2px}
    button.primary{background:linear-gradient(180deg,var(--accent2),#1d4ed8);border:none}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.12)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .stats{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .stat{background:#0b1220;border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px}
    .stat .k{font-size:11px;color:#94a3b8}
    .stat .v{font-size:18px;font-weight:800}
    .canvas-wrap{position:relative}
    canvas{width:100%;height:calc(100vh - 32px);display:block;background:radial-gradient(1200px 600px at 10% -10%,rgba(59,130,246,0.08),transparent), radial-gradient(1000px 800px at 120% 110%,rgba(34,197,94,0.08),transparent), #0b1220;border-radius:16px}
    .badge{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:#0b1220;border:1px solid rgba(255,255,255,0.1);font-size:12px;color:#cbd5e1}
    .footer{font-size:12px;color:#94a3b8}
    .hr{height:1px;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.12),transparent)}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#0f172a;border:1px solid rgba(255,255,255,0.1);font-size:12px}
    .info{font-size:12px;color:#cbd5e1;line-height:1.5}

    .toast{position:absolute;left:50%;top:16px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;background:rgba(16,185,129,0.15);border:1px solid rgba(16,185,129,0.4);backdrop-filter:blur(6px);font-weight:700}
    .modal{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);backdrop-filter:blur(4px)}
    .modal .card{max-width:520px;padding:20px;border-radius:16px;background:#0b1220;border:1px solid rgba(255,255,255,0.12)}
    .modal h3{margin:0 0 8px;font-size:20px}
    .modal p{margin:0 0 12px;color:#cbd5e1;font-size:14px;line-height:1.7}

    @media (max-width: 1024px){
      .wrapper{grid-template-columns:1fr}
      canvas{height:56vh}
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <aside class="panel left">
      <div class="row" style="justify-content:flex-start;gap:8px">
        <span class="badge">👀 視力トレーナー『Focus Play』</span>
      </div>
      <div class="title">モード選択</div>
      <div>
        <label for="mode">トレーニングモード</label>
        <select id="mode">
          <option value="saccade">サッカード（素早い眼球運動）</option>
          <option value="contrast">コントラスト検出</option>
        </select>
      </div>
      <div class="row">
        <label for="difficulty">難易度</label>
        <input id="difficulty" type="range" min="1" max="10" value="5" />
      </div>
      <div class="row">
        <label for="duration">セッション（分）</label>
        <input id="duration" type="number" min="1" max="30" value="3" />
      </div>
      <div>
        <label for="eye">トレーニング対象</label>
        <select id="eye">
          <option value="both">両目</option>
          <option value="right">右目（左目を軽く覆う）</option>
          <option value="left">左目（右目を軽く覆う）</option>
        </select>
      </div>
      <div class="row" style="gap:8px">
        <button id="startBtn" class="primary">▶ 開始</button>
        <button id="pauseBtn" class="ghost" disabled>⏸ 一時停止</button>
        <button id="resetBtn" class="ghost" disabled>⟲ リセット</button>
      </div>

      <div class="hr"></div>

      <div class="title">ステータス</div>
      <div class="stats">
        <div class="stat"><div class="k">スコア</div><div id="statScore" class="v">0</div></div>
        <div class="stat"><div class="k">レベル</div><div id="statLevel" class="v">1</div></div>
        <div class="stat"><div class="k">反応時間</div><div id="statRt" class="v">—</div></div>
        <div class="stat"><div class="k">残り時間</div><div id="statTime" class="v">—</div></div>
      </div>

      <div class="title">ハイスコア</div>
      <div class="stats">
        <div class="stat"><div class="k">サッカード</div><div id="hsSaccade" class="v">0</div></div>
        <div class="stat"><div class="k">コントラスト</div><div id="hsContrast" class="v">0</div></div>
      </div>

      <div class="title">使い方</div>
      <div class="info">
        1) モードと難易度を選んで開始。<br/>
        2) <span class="pill">サッカード</span>：中央の＋を見続け、出現した丸をすばやくクリック。成功でスコア↑・サイズ↓。<br/>
        3) <span class="pill">コントラスト</span>：薄い色の中から "最も濃い" マスをクリック。正解すると差が小さくなり難度↑。<br/>
        4) 長時間は控えめに。<b>20-20-20ルール</b>（20分ごとに20フィート先を20秒見る）も活用してください。
      </div>

      <div class="title">注意</div>
      <div class="footer">このゲームは目の疲労軽減や視覚スキルのトレーニング補助を目的としています。医療行為ではありません。違和感や痛みがある場合は中止し、必要に応じて眼科医に相談してください。</div>
    </aside>

    <main class="panel canvas-wrap">
      <canvas id="stage" width="1400" height="900" aria-label="トレーニングエリア" role="img"></canvas>
      <div id="toast" class="toast" style="display:none"></div>
      <div id="breakModal" class="modal" aria-modal="true">
        <div class="card">
          <h3>ブレイクタイム（20-20-20）</h3>
          <p>20秒間、できるだけ遠くの一点にピントを合わせてください。瞬きを意識し、肩と首を軽く回しましょう。</p>
          <p>残り <span id="breakCountdown">20</span> 秒</p>
          <div class="row" style="gap:8px">
            <button id="skipBreak" class="ghost">スキップ</button>
            <button id="endBreak" class="primary" disabled>再開</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
  ;(() => {
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    const els = {
      mode: document.getElementById('mode'),
      difficulty: document.getElementById('difficulty'),
      duration: document.getElementById('duration'),
      eye: document.getElementById('eye'),
      startBtn: document.getElementById('startBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      resetBtn: document.getElementById('resetBtn'),
      statScore: document.getElementById('statScore'),
      statLevel: document.getElementById('statLevel'),
      statRt: document.getElementById('statRt'),
      statTime: document.getElementById('statTime'),
      hsSaccade: document.getElementById('hsSaccade'),
      hsContrast: document.getElementById('hsContrast'),
      toast: document.getElementById('toast'),
      breakModal: document.getElementById('breakModal'),
      breakCountdown: document.getElementById('breakCountdown'),
      endBreak: document.getElementById('endBreak'),
      skipBreak: document.getElementById('skipBreak'),
    };

    // ---- persistent
    const HS_KEY = 'focusplay_highscores_v1';
    const hs = JSON.parse(localStorage.getItem(HS_KEY) || '{"saccade":0,"contrast":0}');
    function saveHS(){ localStorage.setItem(HS_KEY, JSON.stringify(hs)); }
    function updateHSUI(){ els.hsSaccade.textContent = hs.saccade|0; els.hsContrast.textContent = hs.contrast|0; }
    updateHSUI();

    // ---- global state
    let state = {
      running: false,
      paused: false,
      mode: 'saccade',
      level: 1,
      score: 0,
      rtList: [],
      startAt: 0,
      endAt: 0,
      remainingMs: 0,
      lastBreakAt: 0,
      eye: 'both',
    };

    // ---- utils
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const rand=(min,max)=>Math.random()*(max-min)+min;
    const now=()=>performance.now();

    function showToast(msg, ms=1200){
      els.toast.textContent = msg; els.toast.style.display = 'block';
      setTimeout(()=> els.toast.style.display='none', ms);
    }

    function formatMs(ms){
      if(!isFinite(ms) || ms<=0) return '—';
      return Math.round(ms) + ' ms';
    }

    function drawFixation(){
      const w=canvas.width,h=canvas.height; const cx=w/2, cy=h/2;
      ctx.save();
      ctx.strokeStyle = 'rgba(148,163,184,0.9)';
      ctx.lineWidth = 2; ctx.beginPath();
      ctx.moveTo(cx-18,cy); ctx.lineTo(cx+18,cy); ctx.moveTo(cx,cy-18); ctx.lineTo(cx,cy+18); ctx.stroke();
      ctx.restore();
    }

    function clearStage(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function secondsLeft(){
      if(!state.running) return 0;
      const elapsed = now() - state.startAt;
      const ms = clamp(state.endAt - (state.paused? state.pauseStartAt : now()), 0, Infinity);
      return Math.ceil(ms/1000);
    }

    function updateTimerUI(){
      const ms = (state.paused? state.pauseRemainingMs : (state.endAt - now()));
      els.statTime.textContent = ms>0 ? Math.ceil(ms/1000)+'s' : '0s';
    }

    // ---- break modal (20-20-20)
    let breakTimer=null, breakRemaining=20;
    function openBreak(){
      state.paused=true; els.breakModal.style.display='flex';
      breakRemaining = 20; els.breakCountdown.textContent = breakRemaining;
      els.endBreak.disabled = true;
      if(breakTimer) clearInterval(breakTimer);
      breakTimer = setInterval(()=>{
        breakRemaining--; els.breakCountdown.textContent = breakRemaining;
        if(breakRemaining<=0){ clearInterval(breakTimer); els.endBreak.disabled=false; }
      },1000);
    }
    els.endBreak.addEventListener('click', ()=>{ els.breakModal.style.display='none'; state.paused=false; state.lastBreakAt = now(); scheduleNext(); });
    els.skipBreak.addEventListener('click', ()=>{ if(breakTimer) clearInterval(breakTimer); els.breakModal.style.display='none'; state.paused=false; state.lastBreakAt = now(); scheduleNext(); });

    // ---- Saccade mode
    const saccade = {
      target:null,
      timeoutId:null,
      clickHandler:null,
      baseSize: 38,
      baseWindow: 1200,
      minWindow: 380,
      schedule(){
        if(!state.running || state.paused) return;
        clearStage(); drawFixation();
        const delay = rand(600,1000);
        saccade.timeoutId = setTimeout(()=>{
          // pick a peripheral position
          const w=canvas.width,h=canvas.height,cx=w/2,cy=h/2;
          const r = Math.min(w,h)*0.42; // spawn radius
          const ang = rand(0,Math.PI*2);
          const tx = cx + Math.cos(ang)*r;
          const ty = cy + Math.sin(ang)*r;
          const size = clamp(saccade.baseSize - state.level*2, 12, 48);
          saccade.target = {x:tx,y:ty, r:size, born: now(), life: clamp(saccade.baseWindow - state.level*40, saccade.minWindow, saccade.baseWindow)};
          drawTrial();
        }, delay);
      },
      reset(){
        if(saccade.timeoutId) clearTimeout(saccade.timeoutId);
        saccade.target=null;
      }
    };

    function drawTrial(){
      clearStage(); drawFixation();
      if(!saccade.target) return;
      const t = saccade.target; // circle
      ctx.save();
      ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2);
      ctx.fillStyle = 'rgba(34,197,94,0.9)'; ctx.fill();
      ctx.restore();

      // expire check
      const left = t.life - (now() - t.born);
      if(left<=0){
        // miss
        state.level = Math.max(1, state.level-1);
        state.score = Math.max(0, state.score-1);
        updateUI(); showToast('ミス…');
        saccade.target=null; scheduleNext(); return;
      }
      requestAnimationFrame(drawTrial);
    }

    canvas.addEventListener('click', (e)=>{
      if(!state.running || state.paused) return;
      if(state.mode !== 'saccade') return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width/rect.width);
      const y = (e.clientY - rect.top) * (canvas.height/rect.height);
      if(saccade.target){
        const dx = x - saccade.target.x; const dy = y - saccade.target.y;
        const hit = Math.hypot(dx,dy) <= saccade.target.r;
        if(hit){
          const rt = now() - saccade.target.born;
          state.rtList.push(rt);
          state.score += 2;
          if(state.score % 6 === 0) state.level++;
          updateUI(); showToast('ナイス！ '+Math.round(rt)+' ms');
          saccade.target=null; scheduleNext();
        }
      }
    });

    // ---- Contrast mode
    const contrast = {
      grid: 3,
      delta: 32, // contrast difference (start)
      minDelta: 4,
      base: 180,
      targetIdx: 0,
      cellW: 0,
      cellH: 0,
      layout: [],
      build(){
        const w=canvas.width, h=canvas.height;
        contrast.cellW = Math.floor(w / (contrast.grid+2));
        contrast.cellH = Math.floor(h / (contrast.grid+2));
        contrast.layout = [];
        const total = contrast.grid*contrast.grid;
        contrast.targetIdx = Math.floor(Math.random()*total);
        for(let i=0;i<total;i++){
          const row = Math.floor(i/contrast.grid);
          const col = i%contrast.grid;
          const x = Math.floor((col+1.5)*contrast.cellW);
          const y = Math.floor((row+1.5)*contrast.cellH);
          const val = i===contrast.targetIdx ? (contrast.base - contrast.delta) : contrast.base;
          contrast.layout.push({x,y,w:contrast.cellW*0.8,h:contrast.cellH*0.8,val});
        }
      },
      draw(){
        clearStage(); drawFixation();
        for(const c of contrast.layout){
          ctx.fillStyle = `rgb(${c.val},${c.val},${c.val})`;
          ctx.fillRect(c.x - c.w/2, c.y - c.h/2, c.w, c.h);
        }
      },
      handleClick(x,y){
        const total = contrast.layout.length;
        for(let i=0;i<total;i++){
          const c = contrast.layout[i];
          if(x>=c.x-c.w/2 && x<=c.x+c.w/2 && y>=c.y-c.h/2 && y<=c.y+c.h/2){
            const correct = (i===contrast.targetIdx);
            if(correct){
              state.score += 1;
              state.level += (state.score%5===0)?1:0;
              state.rtList.push(0); // placeholder, not timing-based
              contrast.delta = Math.max(contrast.minDelta, Math.round(contrast.delta*0.9));
              if(state.level%2===0 && contrast.grid<6) contrast.grid++;
              showToast('正解！ コントラスト↓');
            } else {
              state.score = Math.max(0, state.score-1);
              contrast.delta = Math.min(64, Math.round(contrast.delta*1.1));
              showToast('ハズレ… コントラスト↑');
            }
            updateUI(); contrast.build(); contrast.draw();
            break;
          }
        }
      }
    };

    canvas.addEventListener('mousedown', (e)=>{
      if(!state.running || state.paused) return;
      if(state.mode !== 'contrast') return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width/rect.width);
      const y = (e.clientY - rect.top) * (canvas.height/rect.height);
      contrast.handleClick(x,y);
    });

    // ---- session control
    function resetState(){
      state.running=false; state.paused=false;
      state.level=1; state.score=0; state.rtList=[];
      state.startAt=0; state.endAt=0; state.remainingMs=0; state.lastBreakAt=0;
      saccade.reset(); clearStage(); drawFixation(); updateUI();
      els.pauseBtn.disabled=true; els.resetBtn.disabled=true; els.startBtn.disabled=false;
    }

    function start(){
      state.mode = els.mode.value; state.eye = els.eye.value;
      const diff = +els.difficulty.value; const mins = +els.duration.value;
      state.level = clamp(diff,1,10);
      state.score = 0; state.rtList=[];
      state.running=true; state.paused=false;
      const nowt = now();
      state.startAt = nowt; state.endAt = nowt + mins*60*1000; state.lastBreakAt = nowt;
      els.pauseBtn.disabled=false; els.resetBtn.disabled=false; els.startBtn.disabled=true;
      updateUI();
      if(state.mode==='saccade'){ scheduleNext(); }
      else if(state.mode==='contrast'){ contrast.grid=3; contrast.delta= 12 + (11 - state.level)*2; contrast.build(); contrast.draw(); scheduleTick(); }
      showEyeHint();
    }

    function showEyeHint(){
      if(state.eye==='right'){ showToast('左目を軽く覆って右目でプレイ'); }
      if(state.eye==='left'){ showToast('右目を軽く覆って左目でプレイ'); }
    }

    function pause(){
      if(!state.running) return;
      if(!state.paused){
        state.paused=true; state.pauseStartAt = now(); state.pauseRemainingMs = Math.max(0, state.endAt - now());
      } else {
        state.paused=false; state.endAt = now() + state.pauseRemainingMs;
        scheduleNext();
      }
      updateUI();
    }

    function scheduleNext(){
      if(!state.running) return;
      if(state.paused) return;
      if(now() >= state.endAt){ finish(); return; }
      if(now() - state.lastBreakAt > 20*60*1000){ openBreak(); return; }
      if(state.mode==='saccade'){ saccade.schedule(); }
    }

    // general timer to redraw countdown
    let tickId=null;
    function scheduleTick(){
      if(tickId) cancelAnimationFrame(tickId);
      function step(){ updateTimerUI(); if(state.running && !state.paused){ if(now()>=state.endAt){ finish(); return; } } tickId=requestAnimationFrame(step); }
      tickId=requestAnimationFrame(step);
    }

    function finish(){
      state.running=false; state.paused=false; updateUI();
      if(state.mode==='saccade'){ saccade.reset(); }
      showToast('セッション終了！');
      // update HS
      if(state.mode==='saccade' && state.score>hs.saccade){ hs.saccade=state.score; saveHS(); }
      if(state.mode==='contrast' && state.score>hs.contrast){ hs.contrast=state.score; saveHS(); }
      updateHSUI();
      els.pauseBtn.disabled=true; els.startBtn.disabled=false; els.resetBtn.disabled=false;
    }

    function updateUI(){
      els.statScore.textContent = state.score;
      els.statLevel.textContent = state.level;
      const avg = state.rtList.length? state.rtList.reduce((a,b)=>a+b,0)/state.rtList.length : 0;
      els.statRt.textContent = formatMs(avg);
      updateTimerUI();
    }

    // controls
    els.startBtn.addEventListener('click', ()=>{ start(); scheduleTick(); });
    els.pauseBtn.addEventListener('click', ()=>{ pause(); });
    els.resetBtn.addEventListener('click', ()=>{ resetState(); });

    // init
    resetState();
    window.addEventListener('resize', ()=>{ /* canvas auto scales via CSS */ if(state.mode==='contrast' && state.running){ contrast.build(); contrast.draw(); }});
  })();
  </script>
</body>
</html>
